this.xfetch=this.xfetch||{},this.xfetch.fetchMiddleware=function(){"use strict";return function({namespace:e=globalThis||window,fetch:t=e.fetch}={}){if(null==e&&(e=globalThis||window),"object"!=typeof e)throw new Error("[fetch-xhr-middleware] - `namespace` should be an object");if("function"!=typeof t)throw new Error("[fetch-xhr-middleware] - `fetch` should be a function");if("function"==typeof t.onRequest)return t.stopIntercepting;const n="fetch",r=[];async function o(...e){const n=[];let o=new Request(...e),c=null,u=null,f=null,s=null;for(const e of r){let r=await e({request:o,fetch:t,get url(){return f||(e=o.url,f=new URL(e));var e},get headers(){return s||(e=o.headers,s=[...e.entries()].reduce(((e,[t,n])=>(e[t]=n,e)),{}));var e}});r&&(r.request instanceof Request&&(o=r.request),r.response instanceof Response&&(c=r.response),"function"==typeof r.listen&&n.push(r.listen),"string"==typeof r.as&&(u=r.as))}async function i(e){let t=u&&"function"==typeof e[u];return n.forEach((n=>{const r=e.clone();t?r[u]().then(n):n(r)})),e}return c?i(c):t(o).then(i)}function c(){e.fetch=t}return Object.defineProperty(o,"name",{value:n,configurable:!0}),e.fetch=o,o.stopIntercepting=c,o.onRequest=function(e){if("function"!=typeof e)throw new Error("[onRequest] - Argument must be a function");return r.find((t=>t===e))||function(e){r.push(e)}(e),()=>{}},c}}();