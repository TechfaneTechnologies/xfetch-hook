this.xfetch=this.xfetch||{},this.xfetch.fetchMiddleware=function(){"use strict";return function({namespace:e=globalThis||window,fetch:t=e.fetch}={}){if(null==e&&(e=globalThis||window),"object"!=typeof e)throw new Error("[xfetch-hook] - `namespace` should be an object");if("function"!=typeof t)throw new Error("[xfetch-hook] - `fetch` should be a function");if("function"==typeof t.onRequest)return t.stopIntercepting;const n="fetch",o=[];async function r(...e){const n=[];let r=new Request(...e),c=null,f=null,u=null,s=null;for(const e of o){let o=await e({request:r,fetch:t,get url(){return u||(e=r.url,u=new URL(e));var e},get headers(){return s||(e=r.headers,s=[...e.entries()].reduce(((e,[t,n])=>(e[t]=n,e)),{}));var e}});o&&(o.request instanceof Request&&(r=o.request),o.response instanceof Response&&(c=o.response),"function"==typeof o.listen&&n.push(o.listen),"string"==typeof o.as&&(f=o.as))}async function i(e){let t=f&&"function"==typeof e[f];return n.forEach((n=>{const o=e.clone();t?o[f]().then(n):n(o)})),e}return c?i(c):t(r).then(i)}function c(){e.fetch=t}return Object.defineProperty(r,"name",{value:n,configurable:!0}),e.fetch=r,r.stopIntercepting=c,r.onRequest=function(e){if("function"!=typeof e)throw new Error("[xfetch-hook] - `onRequest`: argument must be a function");return o.find((t=>t===e))||function(e){o.push(e)}(e),()=>{}},c}}();